[{"id":"extract_json_action","user_id":"2350b3af-b882-480b-98f4-36904eed49b9","name":"Extract JSON Action","type":"action","content":"\"\"\"\ntitle: Extract JSON Action\nauthors: Kauzre Zheng\nversion: 2.0.1\nlicense: MIT\n\"\"\"\n\nfrom pydantic import BaseModel, Field\nfrom time import strftime\n\nimport os\n\n\ndef extract_text(text, text_begin, text_end):\n    begin = text.rfind(text_begin)\n    if begin == -1:\n        return None\n    begin += len(text_begin)\n    end = text.find(text_end, begin)\n    if end == -1:\n        end = len(text)\n    return text[begin:end]\n\n\nclass Action:\n    class Valves(BaseModel):\n        INBOX: str = Field(\n            default=\"/app/connect/bvtk-bridge/inbox\", description=\"testing\"\n        )\n\n    def __init__(self):\n        self.valves = self.Valves()\n\n    async def action(\n        self,\n        body: dict,\n        __user__=None,\n        __event_emitter__=None,\n        __event_call__=None,\n    ):\n        content = body[\"messages\"][-1][\"content\"]\n        try:\n            # await __event_emitter__({\n            #     \"type\": \"notification\",\n            #     \"data\": {\"type\": \"info\",\n            #              \"content\": f\"Successfully extracted the content\"}\n            # })\n\n            source = extract_text(content, \"```json\", \"```\")\n            if source:\n                # await __event_emitter__({\n                #     \"type\": \"notification\",\n                #     \"data\": {\"type\": \"info\",\n                #              \"content\": f\"{source}\"}\n                # })\n                timestamp = strftime(\"%Y%m%d-%H%M%S\")\n                path = os.path.join(self.valves.INBOX, f\"{timestamp}.json\")\n                # path = os.path.join(self.valves.INBOX, \"test.json\")\n                try:\n                    with open(path, \"w\", encoding=\"utf-8\") as f:\n                        f.write(source)\n                    await __event_emitter__(\n                        {\n                            \"type\": \"notification\",\n                            \"data\": {\n                                \"type\": \"info\",\n                                \"content\": f\"Successfully store the JSON in {path}\",\n                            },\n                        }\n                    )\n                except Exception as e:\n                    await __event_emitter__(\n                        {\n                            \"type\": \"notification\",\n                            \"data\": {\"type\": \"error\", \"content\": f\"Error {str(e)}\"},\n                        }\n                    )\n            else:\n                await __event_emitter__(\n                    {\n                        \"type\": \"notification\",\n                        \"data\": {\n                            \"type\": \"error\",\n                            \"content\": f\"Failed to extract code:\\n{source}\",\n                        },\n                    }\n                )\n        except Exception as e:\n            await __event_emitter__(\n                {\n                    \"type\": \"notification\",\n                    \"data\": {\"type\": \"error\", \"content\": f\"Action failed:\\n{str(e)}\"},\n                }\n            )\n","meta":{"description":"extract JSON from text and save as a file","manifest":{"title":"Extract JSON Action","authors":"Kauzre Zheng","version":"2.0.1","license":"MIT"}},"is_active":false,"is_global":false,"updated_at":1760104613,"created_at":1760104613},{"id":"pipe_graphrag","user_id":"2350b3af-b882-480b-98f4-36904eed49b9","name":"Pipe GraphRAG","type":"pipe","content":"\"\"\"\ntitle: Pipe GraphRAG\nauthors: Kauzre Zheng\nversion: 2.0.0\nlicense: MIT\n\"\"\"\n\nimport subprocess\nfrom pydantic import BaseModel, Field\nimport os\nimport time\nimport threading\nimport queue\n\n\nclass Pipe:\n    class Valves(BaseModel):\n        GRAPHRAG_PATH: str = Field(\n            default=\"/app/graphrag/.venv/bin/python\",\n            description=\"Path to graphrag Python executable\",\n        )\n        RAG_ROOT: str = Field(\n            default=\"./ragtest\", description=\"Root directory for RAG data\"\n        )\n        DEFAULT_METHOD: str = Field(\n            default=\"basic\", description=\"Default search method (basic, local, global)\"\n        )\n        GRAPHRAG_CWD: str = Field(\n            default=os.path.expanduser(\"/app/graphrag\"),\n            description=\"Working directory for graphrag CLI\",\n        )\n        # JSON detection & save options\n        INBOX_DIR: str = Field(\n            default=os.environ.get(\n                \"BVTK_INBOX_DIR\", os.path.expanduser(\"/app/graphrag/inbox\")\n            ),\n            description=\"Directory to save detected Blender JSON actions\",\n        )\n        FILE_PREFIX: str = Field(\n            default=\"task\", description=\"Saved JSON filename prefix\"\n        )\n        SAVE_JSON_FROM_OUTPUT: bool = Field(\n            default=False,\n            description=\"Detect JSON in graphrag stdout and save to inbox\",\n        )\n        STREAM_CHUNK_SIZE: int = Field(\n            default=10, description=\"Number of characters to stream at once\"\n        )\n        STREAM_DELAY: float = Field(\n            default=0.05, description=\"Delay between stream chunks in seconds\"\n        )\n\n    def __init__(self):\n        self.valves = self.Valves()\n\n    def pipes(self):\n        return [\n            {\n                \"id\": \"graphrag_basic_realtime\",\n                \"name\": \"GraphRAG Basic Search (Real-time)\",\n            },\n            {\n                \"id\": \"graphrag_local_realtime\",\n                \"name\": \"GraphRAG Local Search (Real-time)\",\n            },\n            {\n                \"id\": \"graphrag_global_realtime\",\n                \"name\": \"GraphRAG Global Search (Real-time)\",\n            },\n        ]\n\n    def pipe(self, body: dict):\n        messages = body.get(\"messages\", [])\n        if not messages:\n            return {\"answer\": \"No message provided\"}\n\n        question = messages[-1].get(\"content\", \"\")\n        if not question:\n            return {\"answer\": \"Empty question\"}\n\n        model_id = body.get(\"model\", \"graphrag_basic_realtime\")\n        method = \"basic\"\n        if \"local\" in model_id:\n            method = \"local\"\n        elif \"global\" in model_id:\n            method = \"global\"\n\n        cmd = [\n            os.path.expanduser(self.valves.GRAPHRAG_PATH),\n            \"-m\",\n            \"graphrag\",\n            \"query\",\n            \"--root\",\n            self.valves.RAG_ROOT,\n            \"--method\",\n            method,\n            \"--query\",\n            question,\n        ]\n\n        return self._advanced_stream_response(cmd)\n\n    def _advanced_stream_response(self, cmd):\n        try:\n            process = subprocess.Popen(\n                cmd,\n                stdout=subprocess.PIPE,\n                stderr=subprocess.PIPE,\n                text=True,\n                bufsize=1,\n                universal_newlines=True,\n                cwd=self.valves.GRAPHRAG_CWD,\n            )\n            output_queue = queue.Queue()\n\n            def read_output():\n                try:\n                    while True:\n                        output = process.stdout.readline()\n                        if output == \"\" or process.poll() is not None:\n                            break\n                        if output:\n                            output_queue.put(output)\n\n                    stderr_output = process.stderr.read()\n                    if stderr_output:\n                        output_queue.put(f\"[ERROR]{stderr_output}\")\n                    output_queue.put(None)\n                except Exception as e:\n                    output_queue.put(f\"[ERROR] {str(e)}\")\n                    output_queue.put(None)\n\n                read_thread = threading.Thread(target=read_output)\n                read_thread.daemon = True\n                read_thread.start()\n\n                buffer = \"\"\n                while True:\n                    try:\n                        try:\n                            output = output_queue.get(timeout=0.1)\n                        except queue.Empty:\n                            if process.poll() is not None:\n                                break\n                            continue\n                        if output is None:\n                            break\n                        buffer += output\n\n                        while len(buffer) >= self.valves.STREAM_CHUNK_SIZE:\n                            chunk = buffer[: self.valves.STREAM_CHUNK_SIZE]\n                            buffer = buffer[self.valves.STREAM_CHUNK_SIZE :]\n\n                            yield {\n                                \"choice\": [\n                                    {\"delta\": {\"content\": chunk}, \"finish_reason\": None}\n                                ]\n                            }\n                            time.sleep(self.valves.STREAM_DELAY)\n                    except Exception as e:\n                        yield {\n                            \"choices\": [\n                                {\n                                    \"delta\": {\"content\": f\"Error: {str(e)}\"},\n                                    \"finish_reason\": None,\n                                }\n                            ]\n                        }\n                        break\n                if buffer:\n                    yield {\n                        \"choices\": [\n                            {\"delta\": {\"content\": buffer}, \"finish_reason\": None}\n                        ]\n                    }\n                yield {\"choices\": [{\"delta\": {}, \"finish_reason\": \"stop\"}]}\n\n        except Exception as e:\n            yield {\n                \"choices\": [\n                    {\"delta\": {\"content\": f\"ERROR: {str(e)}\"}, \"finish_reason\": \"stop\"}\n                ]\n            }\n\n    def get_pipe_info(self):\n        return {\n            \"name\": \"GraphRAG Advanced Streaming Integration\",\n            \"description\": \"Advanced streaming integration with character-level real-time output\",\n            \"version\": \"2.0.0\",\n            \"methods\": [\"basic\", \"local\", \"global\"],\n            \"features\": [\n                \"streaming\",\n                \"real-time\",\n                \"character-level\",\n                \"local-deployment\",\n                \"typing-effect\",\n            ],\n        }\n","meta":{"description":"communicate with GraphRAG through pipe","manifest":{"title":"Pipe GraphRAG","authors":"Kauzre Zheng","version":"2.0.0","license":"MIT"}},"is_active":false,"is_global":false,"updated_at":1760104681,"created_at":1760104681}]