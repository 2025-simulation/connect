[{"id":"extract_json_action","user_id":"87591b2f-8981-498d-9bfd-c860e6b6bff7","name":"Extract JSON Action","type":"action","content":"\"\"\"\ntitle: Extract JSON Action\nauthors: Kauzre Zheng\nversion: 2.0.1\nlicense: MIT\n\"\"\"\n\nfrom pydantic import BaseModel, Field\nfrom time import strftime\n\nimport os\n\n\ndef extract_text(text, text_begin, text_end):\n    begin = text.rfind(text_begin)\n    if begin == -1:\n        return None\n    begin += len(text_begin)\n    end = text.find(text_end, begin)\n    if end == -1:\n        end = len(text)\n    return text[begin:end]\n\n\nclass Action:\n    class Valves(BaseModel):\n        INBOX: str = Field(\n            default=\"/app/connect/bvtk-bridge/inbox\", description=\"testing\"\n        )\n\n    def __init__(self):\n        self.valves = self.Valves()\n\n    async def action(\n        self,\n        body: dict,\n        __user__=None,\n        __event_emitter__=None,\n        __event_call__=None,\n    ):\n        content = body[\"messages\"][-1][\"content\"]\n        try:\n            # await __event_emitter__({\n            #     \"type\": \"notification\",\n            #     \"data\": {\"type\": \"info\",\n            #              \"content\": f\"Successfully extracted the content\"}\n            # })\n\n            source = extract_text(content, \"```json\", \"```\")\n            if source:\n                # await __event_emitter__({\n                #     \"type\": \"notification\",\n                #     \"data\": {\"type\": \"info\",\n                #              \"content\": f\"{source}\"}\n                # })\n                timestamp = strftime(\"%Y%m%d-%H%M%S\")\n                path = os.path.join(self.valves.INBOX, f\"{timestamp}.json\")\n                # path = os.path.join(self.valves.INBOX, \"test.json\")\n                try:\n                    with open(path, \"w\", encoding=\"utf-8\") as f:\n                        f.write(source)\n                    await __event_emitter__(\n                        {\n                            \"type\": \"notification\",\n                            \"data\": {\n                                \"type\": \"info\",\n                                \"content\": f\"Successfully store the JSON in {path}\",\n                            },\n                        }\n                    )\n                except Exception as e:\n                    await __event_emitter__(\n                        {\n                            \"type\": \"notification\",\n                            \"data\": {\"type\": \"error\", \"content\": f\"Error {str(e)}\"},\n                        }\n                    )\n            else:\n                await __event_emitter__(\n                    {\n                        \"type\": \"notification\",\n                        \"data\": {\n                            \"type\": \"error\",\n                            \"content\": f\"Failed to extract code:\\n{source}\",\n                        },\n                    }\n                )\n        except Exception as e:\n            await __event_emitter__(\n                {\n                    \"type\": \"notification\",\n                    \"data\": {\"type\": \"error\", \"content\": f\"Action failed:\\n{str(e)}\"},\n                }\n            )\n","meta":{"description":"extract JSON from text and save as a file","manifest":{"title":"Extract JSON Action","authors":"Kauzre Zheng","version":"2.0.1","license":"MIT"}},"is_active":false,"is_global":false,"updated_at":1761708068,"created_at":1761708068},{"id":"pipe_graphrag","user_id":"87591b2f-8981-498d-9bfd-c860e6b6bff7","name":"Pipe GraphRAG","type":"pipe","content":"\"\"\"\ntitle: Pipe GraphRAG\nauthors: Kauzre Zheng\nversion: 2.2.0\nlicense: MIT\n\"\"\"\n\nimport subprocess\nfrom pydantic import BaseModel, Field\nimport os\nimport time\nimport threading\nimport queue\n\n\n# Try to import JSON helpers for Blender actions; provide robust fallbacks\ndef _import_schema_utils():\n    try:\n        from schemas.blender_actions import (\n            parse_actions_json,\n            save_validated_actions,\n        )\n\n        return parse_actions_json, save_validated_actions\n    except Exception:\n        try:\n            # Add project root for relative import when running from OpenWebUI\n            from pathlib import Path\n\n            project_root = os.environ.get(\"CONNECT_PROJECT_ROOT\") or str(\n                Path(__file__).resolve().parents[1]\n            )\n            if project_root not in os.sys.path:\n                os.sys.path.append(project_root)\n            from schemas.blender_actions import (  # type: ignore\n                parse_actions_json,\n                save_validated_actions,\n            )\n\n            return parse_actions_json, save_validated_actions\n        except Exception:\n            # Last resort lightweight implementations\n            import json as _json\n\n            def _parse_actions_json(json_str: str):\n                data = _json.loads(json_str)\n                if not isinstance(data, dict) or not isinstance(\n                    data.get(\"actions\"), list\n                ):\n                    raise ValueError(\"JSON must contain an 'actions' list\")\n                return data\n\n            def _save_validated_actions(plan, inbox_dir: str, prefix: str = \"task\"):\n                from time import strftime\n\n                os.makedirs(inbox_dir, exist_ok=True)\n                ts = strftime(\"%Y%m%d-%H%M%S\")\n                path = os.path.join(inbox_dir, f\"{prefix}-{ts}.json\")\n                if hasattr(plan, \"model_dump_json\"):\n                    content = plan.model_dump_json(indent=2, by_alias=True)\n                else:\n                    content = _json.dumps(plan, ensure_ascii=False, indent=2)\n                with open(path, \"w\", encoding=\"utf-8\") as f:\n                    f.write(content)\n                return path\n\n            return _parse_actions_json, _save_validated_actions\n\n\nparse_actions_json, save_validated_actions = _import_schema_utils()\n\n\nclass Pipe:\n    class Valves(BaseModel):\n        GRAPHRAG_PATH: str = Field(\n            default=\"/app/graphrag/.venv/bin/python\",\n            description=\"Path to graphrag Python executable\",\n        )\n        RAG_ROOT: str = Field(\n            default=\"./ragtest\", description=\"Root directory for RAG data\"\n        )\n        DEFAULT_METHOD: str = Field(\n            default=\"basic\", description=\"Default search method (basic, local, global)\"\n        )\n        GRAPHRAG_CWD: str = Field(\n            default=os.path.expanduser(\"/app/graphrag\"),\n            description=\"Working directory for graphrag CLI\",\n        )\n        # JSON detection & save options\n        INBOX_DIR: str = Field(\n            default=os.environ.get(\n                \"BVTK_INBOX_DIR\", os.path.expanduser(\"/app/graphrag/inbox\")\n            ),\n            description=\"Directory to save detected Blender JSON actions\",\n        )\n        FILE_PREFIX: str = Field(\n            default=\"task\", description=\"Saved JSON filename prefix\"\n        )\n        SAVE_JSON_FROM_OUTPUT: bool = Field(\n            default=False,\n            description=\"Detect JSON in graphrag stdout and save to inbox\",\n        )\n        STREAM_CHUNK_SIZE: int = Field(\n            default=10, description=\"Number of characters to stream at once\"\n        )\n        STREAM_DELAY: float = Field(\n            default=0.05, description=\"Delay between stream chunks in seconds\"\n        )\n\n    def __init__(self):\n        self.valves = self.Valves()\n\n    def pipes(self):\n        return [\n            {\n                \"id\": \"graphrag-basic-realtime\",\n                \"name\": \"GraphRAG Basic Search (Real-time)\",\n            },\n            {\n                \"id\": \"graphrag-local-realtime\",\n                \"name\": \"GraphRAG Local Search (Real-time)\",\n            },\n            {\n                \"id\": \"graphrag-global-realtime\",\n                \"name\": \"GraphRAG Global Search (Real-time)\",\n            },\n        ]\n\n    def pipe(self, body: dict):\n        try:\n            messages = body.get(\"messages\", [])\n            question = messages[-1].get(\"content\", \"\")\n\n            model_id = body.get(\"model\", \"graphrag-basic-realtime\")\n            method = \"basic\"  # 默认方法\n\n            if \"local\" in model_id:\n                method = \"local\"\n            elif \"global\" in model_id:\n                method = \"global\"\n\n            cmd = [\n                os.path.expanduser(self.valves.GRAPHRAG_PATH),\n                \"-m\",\n                \"graphrag\",\n                \"query\",\n                \"--root\",\n                self.valves.RAG_ROOT,\n                \"--method\",\n                method,\n                \"--query\",\n                question,\n            ]\n\n            return self._advanced_stream_response(cmd)\n\n        except Exception as e:\n            return [\n                {\n                    \"id\": \"error\",\n                    \"name\": f\"Error failed to access the question:\\n{e}\",\n                },\n            ]\n\n    def _advanced_stream_response(self, cmd):\n        \"\"\"高级流式输出，支持字符级别的实时显示\"\"\"\n        try:\n            process = subprocess.Popen(\n                cmd,\n                stdout=subprocess.PIPE,\n                stderr=subprocess.PIPE,\n                text=True,\n                bufsize=1,\n                universal_newlines=True,\n                cwd=self.valves.GRAPHRAG_CWD,\n            )\n\n            output_queue = queue.Queue()\n\n            def read_output():\n                try:\n                    while True:\n                        output = process.stdout.readline()\n                        if output == \"\" and process.poll() is not None:\n                            break\n                        if output:\n                            output_queue.put(output)\n                    stderr_output = process.stderr.read()\n                    if stderr_output:\n                        output_queue.put(f\"[Error] {stderr_output}\")\n                    output_queue.put(None)  # 结束信号\n                except Exception as e:\n                    output_queue.put(f\"[Error] {str(e)}\")\n                    output_queue.put(None)\n\n            read_thread = threading.Thread(target=read_output)\n            read_thread.daemon = True\n            read_thread.start()\n\n            buffer = \"\"\n            json_saved = False\n            while True:\n                try:\n                    try:\n                        output = output_queue.get(timeout=0.1)\n                    except queue.Empty:\n                        if process.poll() is not None:\n                            break\n                        continue\n\n                    if output is None:\n                        break\n\n                    buffer += output\n\n                    while len(buffer) >= self.valves.STREAM_CHUNK_SIZE:\n                        chunk = buffer[: self.valves.STREAM_CHUNK_SIZE]\n                        buffer = buffer[self.valves.STREAM_CHUNK_SIZE :]\n\n                        yield {\n                            \"choices\": [\n                                {\"delta\": {\"content\": chunk}, \"finish_reason\": None}\n                            ]\n                        }\n\n                        time.sleep(self.valves.STREAM_DELAY)\n\n                except Exception as e:\n                    yield {\n                        \"choices\": [\n                            {\n                                \"delta\": {\"content\": f\"Error: {str(e)}\"},\n                                \"finish_reason\": None,\n                            }\n                        ]\n                    }\n                    break\n\n            if buffer:\n                yield {\n                    \"choices\": [{\"delta\": {\"content\": buffer}, \"finish_reason\": None}]\n                }\n\n            yield {\"choices\": [{\"delta\": {}, \"finish_reason\": \"stop\"}]}\n\n        except Exception as e:\n            yield {\n                \"choices\": [\n                    {\"delta\": {\"content\": f\"Error: {str(e)}\"}, \"finish_reason\": \"stop\"}\n                ]\n            }\n","meta":{"description":"communicate with GraphRAG through pipe","manifest":{"title":"Pipe GraphRAG","authors":"Kauzre Zheng","version":"2.2.0","license":"MIT"}},"is_active":false,"is_global":false,"updated_at":1761708091,"created_at":1761708068}]